import _ from 'lodash';
import log from '../server/logger';
import DataLoader from 'dataloader';
import findByIds from 'mongo-find-by-ids';
import { CREATE, READ, READONE, READMANY, UPDATE, DELETE, DEBUG } from './constants';

export default class User {
  constructor(context) {
    /*  this is generated from ...
        @authorize(
          admin: ["create", "read", "update", "delete"]
          this: ["readOne", "update", "delete"]
        )
    */
    this.authorizations = {
      admin: {
        create: true,
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
      this: {
        readOne: true,
        update: true,
        delete: true,
      },
    };
    this.context = context;
    this.collection = context.db.collection('user');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader(ids => findByIds(this.collection, ids));
  }

  // returns the role of the current user 
  // generated by...
  // role: String! @authRole("admin") @authorize(this: ["read"], admin: ["read", "update"])
  //       ------- ------------------
  // whereas the field is not of type User, it is of type String
  role(user){
    return (user && user.role) ? user.role : null;
  }

  // returns true, if the user's role is of expected kind
  // this is generated whenever @authorize appears in the type definition
  hasUserRole({role, doc, user, mode, printLog = true, resolver}){
    let hasRole = false;
    switch (role) {
      // returns true, if signed in user has a role "admin"
      // this is generated by...
      // @authorize(admin: ["create", "read", "update", "delete"]) 
      //            -----
      // and if there is no @authRole("admin") user on any of the fields
      // then it assumes a role definition
      // and it checks against the role of the signed in user
      case 'admin':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // the current user has the correct role
          this.context.User.role(user) === 'admin'
        );
        break;
      // returns true, if the signed in user is equal to the document id 
      // this is generated by...
      // @authorize(this:)
      //            -----
      case 'this':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // valid document user id available
          !!doc && !!doc._id && doc._id.toString() !== '' &&
          // document user id equals signed in user
          doc._id.toString() === user._id.toString()
        );
        break;
    }
    if (printLog){
      log.debug('');
      log.debug(`${resolver} hasRole: "${role}" "${user.username ? user.username : ''} ${user.role ? user.role : ''} ${user._id ? user._id : ''}" ==> "${hasRole}"`);
    }
    return hasRole;
  }

  // returns true, if the user role is authorized for the current mode
  // this is generated whenever @authorize appears in the type definition
  isRoleAuthorizedForMode({role, mode, resolver}){
    log.debug(`${resolver} isRoleAuthorizedForMode: "${role}" "${mode}" ==> "${this.authorizations[role][mode] ? true : false}"`);
    return this.authorizations[role][mode] ? true : false;
  }

  // returns true, if the current user is authorized for the current mode and document
  // this is generated, whenever @authorize appears...
  isAuthorized({doc, mode, user, resolver}){

    // generated by @authorize(admin: ...)
    const adminAuthorized = this.hasUserRole({role: 'admin', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'admin', mode, resolver});

    // logging for debugging...
    if (adminAuthorized){
      log.debug(`${resolver} isAuthorized: role: "${
        (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : '<no role found>'
      }" "${mode}" doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${adminAuthorized}"`);

      return adminAuthorized;
    }

    // generated by @authorize(this: ...)
    const thisAuthorized = this.hasUserRole({role: 'this', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'this', mode, resolver});

    // logging for debugging...
    if (thisAuthorized) {
      log.debug(`${resolver} isAuthorized: doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" "${mode}" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${thisAuthorized}"`);

      return thisAuthorized;        
    }

    // logging for debugging...
    log.debug(`${resolver} isAuthorized: role: "${
      (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : '<no role found>'
    }" "${mode}" doc: "${
      (doc && doc._id) ? doc._id.toString() : '<no doc found>'
    }" user: "${
      (user && user._id) ? user._id.toString() : '<no user found>'
    }" ===> "false"`);

    return false;
  }

  // returns document without role field
  // generated by...
  // role: String! @authRole("admin") @authorize(this: ["read"], admin: ["read", "update"])
  //       ------- ------------------ 
  authorizedFields({doc, mode, user, resolver}){
    // array contains all fields, whose authorization is to be checked
    // role: String! @authorize()
    // ----          ------------
    const fields = ['role'];

    // check authorization on field level now
    fields.forEach(field => {
      // default is: field is not authorized
      let authorizedField = false;

      // role: String! @authorize()
      // ----          ------------
      if (field === 'role'){
        log.debug('');
        // role: String! @authorize(this: ["read"])
        // -----                    -----   ----
        if ( this.hasUserRole({role: 'this', doc, user, mode, printLog: false, resolver}) &&
          (mode === READ || mode === READONE || mode === READMANY) ){
          log.debug(`${resolver} authorizedFields: "${field}" is authorized for role: "this" and mode: "${mode}"`);
          authorizedField = true;
        }

        // role: @authorize(admin: ["create", "read", "update"])
        // ----             -----    ------    ----    ------
        if ( this.hasUserRole({role: 'admin', doc, user, mode, printLog: false, resolver})  &&
          (mode === CREATE || mode === READ || mode === READONE || mode === READMANY || mode === UPDATE) ){
          log.debug(`${resolver} authorizedFields: "${field}" is authorized for role: "admin" and mode: "${mode}"`);
          authorizedField = true;
        }
      }

      // ... Checking fields here...

      // otherwise remove field from doc, 
      // because the user and mode is not authorize to access this field
      if ( !authorizedField && doc[field] ){
        log.debug(`${resolver} authorizedFields: "${field}" not authorized for user/role and mode: "${mode}", removed from document`);
        delete doc[field];
      }
    });

    return doc;
  }

  // returns only authorized documents and fields
  // generated by ...
  // @authorize()
  authorized({doc, mode, user, resolver}){
    // if it is an array of documents, ....
    if (_.isArray(doc)){
      // then filter for the authorized documents
      let authorizedDocs = _.filter(doc, d => this.isAuthorized({doc: d, mode, user, resolver}) );
      // provide only authorized fields
      authorizedDocs.forEach(d => {
        d = this.authorizedFields({doc: d, mode, user, resolver});
      });
      return authorizedDocs;

    // if it is a single document, check the authorization for it
    } else if ( _.isObject(doc) && this.isAuthorized({doc, mode, user, resolver}) ) {
      // return only authorized fields
      const authorizedDoc = this.authorizedFields({doc, mode, user, resolver});
      return authorizedDoc;
    }

    // or return null, if no authorized document was found
    log.debug(`${resolver} authorized: no authorized doc found`);
    return null;
  }

  async findOneById(id, _user) {
    //console.log('findOneById _user', id, JSON.stringify(_user, null, 2));
    const doc = await this.loader.load(id);
    return doc;
    // wanted to do the authorization here, but in the query, the user is false, in mutations and resolvers it is there, why?
    // the following doesn't work, because the user is not there at this point of time for a reason I don't understand
    // const authorizedDoc = this.authorized({doc: doc, mode: READONE, user: user});
    // return authorizedDoc;
  }

  async all({ lastCreatedAt = 0, limit = 10 }, _user) {
    //console.log('findOneById _user', id, JSON.stringify(_user, null, 2));
    const doc = await this.collection.find({
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    return doc;
    // wanted to do the authorization here, but in the query, the user is false, in mutations and resolvers it is there, why?
    // the following doesn't work, because the user is not there at this point of time for a reason I don't understand
    // const authorizedDocs = this.authorized({doc, mode: READMANY, user});
    // return authorizedDocs;
  }

  async tweets(user, { minLikes, lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.Tweet.collection.find({
      authorId: user._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    const authorizedDoc = this.context.Tweet.authorized({doc, mode: READMANY, user: _user, resolver: 'tweets'});
    return authorizedDoc;
  }

  async liked(user, { lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.Tweet.collection.find({
      _id: { $in: user.likedIds || [] },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    const authorizedDoc = this.context.Tweet.authorized({doc, mode: READMANY, user: _user, resolver: 'liked'});
    return authorizedDoc;
  }

  async following(user, { lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.User.collection.find({
      _id: { $in: user.followingIds || [] },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    const authorizedDoc = this.authorized({doc, mode: READMANY, user: _user, resolver: 'following'});
    return authorizedDoc;
  }

  async followers(user, { lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.User.collection.find({
      followingIds: user._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    const authorizedDoc = this.authorized({doc, mode: READMANY, user: _user, resolver: 'followers'});
    return authorizedDoc;
  }

  async createdBy(user, _user) {
    const doc = await this.context.User.findOneById(user.createdById, _user);
    const authorizedDoc = this.authorized({doc, mode: READONE, user: _user, resolver: 'createdBy'});
    return authorizedDoc;
  }

  async updatedBy(user, _user) {
    const doc = await this.context.User.findOneById(user.updatedById, _user);
    const authorizedDoc = this.authorized({doc, mode: READONE, user: _user, resolver: 'updatedBy'});
    return authorizedDoc;
  }

  async insert(doc, _user) {
    let docToInsert = Object.assign({}, doc, {
      createdAt: Date.now(),
      updatedAt: Date.now(),
      createdById: (_user && _user._id) ? _user._id : 'unknown',
      updatedById: (_user && _user._id) ? _user._id : 'unknown',
    });
    docToInsert = this.authorizedFields({doc: docToInsert, mode: CREATE, user: _user, resolver: 'insert'});
    const authorized = this.isAuthorized({doc: docToInsert, mode: CREATE, user: _user, resolver: 'insert'});
    if (!authorized) throw new Error('User: mode: create not authorized');

    const id = (await this.collection.insertOne(docToInsert)).insertedId;
    this.pubsub.publish('userInserted', await this.findOneById(id, _user));
    return id;
  }

  async updateById(id, doc, _user) {
    const foundDoc = await this.findOneById(id);
    const authorized = this.isAuthorized({doc: foundDoc, mode: UPDATE, user: _user, resolver: 'updateById'});
    if (!authorized) throw new Error('User: mode: update not authorized');

    const updatedDoc = this.authorizedFields({doc, mode: UPDATE, user: _user, resolver: 'updateById'});
    const ret = await this.collection.update({ _id: id }, {
      $set: Object.assign({}, updatedDoc, {
        updatedAt: Date.now(),
        updatedById: (_user && _user._id) ? _user._id : 'unknown',
      }),
    });
    this.loader.clear(id);
    this.pubsub.publish('userUpdated', await this.findOneById(id, _user));
    return ret;
  }

  async removeById(id, _user) {
    const doc = await this.findOneById(id, _user);
    const authorized = this.isAuthorized({doc, mode: DELETE, user: _user, resolver: 'removeById'});
    if (!authorized) throw new Error('User: mode: delete not authorized');

    const ret = this.collection.remove({ _id: id });
    this.loader.clear(id);
    this.pubsub.publish('userRemoved', id);
    return ret;
  }
}
