import _ from 'lodash';
import DataLoader from 'dataloader';
import findByIds from 'mongo-find-by-ids';
import { CREATE, READ, READONE, READMANY, UPDATE, DELETE, DEBUG } from './constants';

export default class Tweet {
  constructor(context) {
    /*  this is generated from ...
        @authorize(
          author: ["create", "read", "update", "delete"], 
          coauthors: ["read", "update"],
          admin: ["read", "update", "delete"], 
          world: ["read"]
        )
    */
    this.authorizations = {
      author: {
        create: true,
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
      coauthors: {
        read: true,
        readOne: true,
        readMany: true,
        update: true,
      },
      admin: {
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
      world: {
        read: true,
        readOne: true,
        readMany: true,
      }
    };
    this.context = context;
    this.collection = context.db.collection('tweet');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader(ids => findByIds(this.collection, ids));
  }

  // returns true, if the user's role is of expected kind
  // this is generated whenever @authorize appears in the type definition
  hasUserRole({role, doc, user, mode}){
    let hasRole = false;
    switch (role) {

      // returns true, if the signed in user is an author
      // this is generated by...
      // author: User! @unmodifiable @belongsTo @authRole("author")
      //         -----                          -------------------
      case 'author':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // valid document author available
          !!doc && !!doc.authorId && doc.authorId.toString() !== '' &&
          // document author equals signed in user
          doc.authorId.toString() === user._id.toString()
        );
        break;

      // returns true, if the signed in user is one of the coauthors
      // this is generated by...
      // coauthors: [User!] @belongsTo @authRole("coauthors")
      //            -------            ----------------------
      case 'coauthors':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // document has at least one coauthors
          !!doc && !!doc.coauthorsIds && _.isArray(doc.coauthorsIds) && doc.coauthorsIds.length > 0 &&
          // current signed in user is a coauthors
          _.indexOf(doc.coauthorsIds, user._id.toString()) > -1
        );
        break;

      // returns true, if signed in user has a role "admin"
      // this is generated by...
      // @authorize(admin: ["read", "update", "delete"]) 
      //            -----
      // and if there is no @authRole("admin") user on any of the fields
      // then it assumes a role definition
      // and it checks against the role of the signed in user
      case 'admin':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // the current user has the correct role
          this.context.User.role(user) === 'admin'
        );
        break;

      // returns true, if user has a role "world"
      // this is generated by...
      // @authorize(world: ["read"])
      //            -----
      // and if there is no @authRole("world") user on any of the fields
      // then it assumes the special role definition "world"
      // which means for every user, signed in or not signed in
      case 'world':
        hasRole = true;
        break;

    }

    (DEBUG) ? console.log(
      '\n---------------------------------------------------------------------------------\n',
      'hasRole?','\n',
      'check if role =', role,'\n',
      'for user:', user.username, user.role, user._id, '\n',
      'doc:', JSON.stringify(doc, null, 2),'\n',
      '==>', hasRole
      )
    : null;

    return hasRole;
  }

  // returns true, if the user role is authorized for the current mode
  // this is generated whenever @authorize appears in the type definition
  isRoleAuthorizedForMode({role, mode}){
    (DEBUG) ? 
      console.log(
        'isRoleAuthorizedForMode?', '\n',
        'role:', role, 
        'mode:', mode, 
        '==>', this.authorizations[role][mode] ? true : false,
        '\n---------------------------------------------------------------------------------\n',
      ) 
      : null;
    return this.authorizations[role][mode] ? true : false;
  }

  // returns true, if the current user is authorized for the current mode and document
  // this is generated, whenever @authorize appears...
  isAuthorized({doc, mode, user}){
    // for authorization DEBUGging and logging reasons, do individual checks...

    // generated by @authorize(author: ...)
    const authorAuthorized = this.hasUserRole({role: 'author', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'author', mode});
    if (authorAuthorized && DEBUG) {
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        'Author:', (doc && doc.authorId) ? doc.authorId.toString() : 'Error', 
        "===>", 'Authorized:', authorAuthorized
      );
    }
    
    // generated by @authorize(coauthors: ...)
    const coauthorsAuthorized = this.hasUserRole({role: 'coauthors', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'coauthors', mode});
    if (coauthorsAuthorized && DEBUG) {
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        'Coauthors:', (doc && doc.coauthorsIds) ? doc.coauthorsIds.toString() : 'Error', 
        "===>", 'Authorized:', coauthorsAuthorized
      );
    }

    // generated by @authorize(admin: ...)
    const adminAuthorized = this.hasUserRole({role: 'admin', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'admin', mode});
    if (adminAuthorized && DEBUG){
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        'Role:', (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : 'Error', 
        "===>", 'Authorized:', adminAuthorized
      );
    }

    // generated by @authorize(world: ...)
    const worldAuthorized = this.hasUserRole({role: 'world', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'world', mode});
    if (worldAuthorized && DEBUG) {
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        'Role:', 'world', 
        "===>", 'Authorized:', worldAuthorized
      );
    }

    // generated by @authorize(author: ..., coauthors: ..., admin: ..., world: ...)
    const authResult = authorAuthorized || coauthorsAuthorized || adminAuthorized || worldAuthorized;
    if (!authResult && DEBUG) {
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        "===>", 'Authorized:', authResult
      );
    }

    return authResult;
  }

  // returns only authorized documents
  authorized({doc, mode, user}){
    if (_.isArray(doc)){
      return _.filter(doc, d => this.isAuthorized({doc: d, mode, user}) );
    } else if (_.isObject(doc) && this.isAuthorized({doc, mode, user})) {
      return doc;
    } else {
      return null;
    }
  }

  async findOneById(id) {
    const doc = await this.loader.load(id);
    return doc;
  }

  async all({ lastCreatedAt = 0, limit = 10 }) {
    const docs = await this.collection.find({
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    return docs;
  }

  author(tweet) {
    return this.context.User.findOneById(tweet.authorId);
  }

  createdBy(tweet) {
    return this.context.User.findOneById(tweet.createdById);
  }

  updatedBy(tweet) {
    return this.context.User.findOneById(tweet.updatedById);
  }

  coauthors(tweet, { lastCreatedAt = 0, limit = 10 }) {
    return this.context.User.collection.find({
      _id: { $in: tweet.coauthorsIds },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  likers(tweet, { lastCreatedAt = 0, limit = 10 }) {
    return this.context.User.collection.find({
      likedIds: tweet._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  // adding the current signed in user as a document owner
  // the field of the document owner is identified
  // by a field in the type definition, which contains an @authRole
  addUserToDoc({doc, mode, user}){
    let enhancedDoc = Object.assign({}, doc);

    // generated by...
    // author: User! @unmodifiable @belongsTo @authRole("author")
    //         -----                          -------------------
    if (user && user._id){
      enhancedDoc = Object.assign({}, { authorId: user._id}, enhancedDoc);
    }

    // generated by ...
    // coauthors: [User!] @belongsTo @authRole("coauthors")
    //            -------            ----------------------
    // TODO: is this logically correct?
    if (user && user._id){
      let coauthorsIds = enhancedDoc.coauthorsIds || [];
      coauthorsIds = _.union(coauthorsIds, [user._id]);
      enhancedDoc = Object.assign({}, { coauthorsIds: coauthorsIds}, enhancedDoc);
    }

    // generated by...
    // createdBy: User! @unmodifiable @belongsTo
    //         -----                          -------------------
    if (mode === CREATE && user && user._id){
      enhancedDoc = Object.assign({}, { createdById: user._id}, enhancedDoc);
    }

    // generated by...
    // changedBy: User! @unmodifiable @belongsTo
    //         -----                          -------------------
    if (mode === UPDATE && user && user._id){
      enhancedDoc = Object.assign({}, { updatedById: user._id}, enhancedDoc);
    }

    return enhancedDoc;
  }

  async insert(doc) {
    const docToInsert = Object.assign({}, doc, {
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    const id = (await this.collection.insertOne(docToInsert)).insertedId;
    this.pubsub.publish('tweetInserted', await this.findOneById(id));
    return id;
  }

  async updateById(id, doc) {
    const ret = await this.collection.update({ _id: id }, {
      $set: Object.assign({}, doc, {
        updatedAt: Date.now(),
      }),
    });
    this.loader.clear(id);
    this.pubsub.publish('tweetUpdated', await this.findOneById(id));
    return ret;
  }

  async removeById(id) {
    const ret = this.collection.remove({ _id: id });
    this.loader.clear(id);
    this.pubsub.publish('tweetRemoved', id);
    return ret;
  }
}
