# create-graphql-server

This is a generated create-graphql-server app.

## Implementing Authorizations
Use the @authorize directive in a \<type\>.graphql input file, to define which authorizations should be generated by create-graphql-server. You can define user-roles and document-roles to control authorizations.

* user-roles: e.g. User.role = "admin", all admins are allowed to do create, read, update, delete,...
* document-roles: e.g. Tweet.authorId = User._id, only authors are allowed to create, update, delete a document

On field level you can control access also by the @authorize directive
e.g. updating the User with set role = "admin", shouldn't be allowed by for all users. So we need a way to restrict the create, read, update, delete operations also on field level if required.

Use the following syntax for the Tweet.graphql input file::
```javascript
type Tweet 

@authorize(
  admin: ["create", "read", "update", "delete"], 
  author: ["create", "read", "update", "delete"], 
  coauthors: ["read", "update"],
  world: ["read"]
)

{
  author: User! @unmodifiable @belongsTo @authRole("author")
  coauthors: [User] @belongsTo @authRole("coauthors")
  body: String!

  likers: [User!] @hasAndBelongsToMany(as: "liked")
}
```
This has the following meaning:
* user-roles: "admin", "world" are created (user roles don't have own fields of type User or [User] in the document)
  This will check, if the logged in user has a role "admin". Or if there is a special role "world", which just means every known or unknown user, for "world" you don't have to be logged in.
  So each "admin" user will be able to create, read, update or delete the Tweet document.
  Everyone ("world") will be allowed to read all Tweets.
* document-roles: "author", "coauthors" are created (document roles have fields in the document)
  Look for the fields with the directive @authRole("...")
  Only the author of a Tweet is allowed to create, read, update, delete its single Tweet.
  Only a coauthor of a Tweet is allowed to read and update a Tweet, but he is not allowed to create a Tweet for a different author, and also not to delete a tweet of a different user.


and for the User.graphql input file:
```javascript
type User

@authorize(
  admin: ["create", "read", "update", "delete"]
  this: ["readOne", "update", "delete"]
)

{
  role: String! @authRole("admin") @authorize(admin: ["create", "read", "update", "delete"], this: ["readOne", "delete"])

  username: String!

  bio: String
  notify: Boolean

  tweets(minLikes: Int): [Tweet!] @hasMany(as: "author")
  liked: [Tweet!] @belongsToMany

  following: [User!] @belongsToMany
  followers: [User!] @hasAndBelongsToMany(as: "following")
}
```
This has the following meaning:
* user-role: "admin", is created (user roles don't have own fields of type User or [User] in the document)
  It is a String field with: **role: String! @authRole("admin")**
  This will check, if the logged in user has a role "admin".
  So each "admin" user will be able to create, read, update or delete any User document.
* document-role: "this", is created (document roles have own fields in the document, but this is a special case for the field _id, which is not shown in the input type, but will be generated in the later schema file.)
  Only the user id of "this" meaning _id is allowed  to readOne, update, delete its single User document.

Here we use also the @authorize directive on field level for the field role:
```javascript
...
role: String! @authRole("admin") @authorize(admin: ["create", "read", "update", "delete"], this: ["readOne", "delete"])
...
```
This adds additional authorization checks on the field level just for this field "role".
Every time this field "role" appears in any document, it will be checked, if the user is authorized to do the operation on this document containing this field. If the field is not in the document, it skips the field check.

In this case it checks:
* if the user-role "admin" is the authorized user, then it allows him to create, read, update, delete operations also on the document, if it contains the field "role"
* if the document-role "this" (=owner of the document user._id_ = doc._id_) to do the operations "readOne" and "delete" on the User document, but it doesn't allow him to upgrade/update his own User.role.

Use create-graphql-server cli to generate the according schema, resolver, model files with the create-graphql-server command line interface. After its generation, you will find the generated files in the sub folders: schema, resolvers, model folders. The generated model files will use the following functions to implement the authorization logic.

### <type> model.js

```javascript
import DataLoader from 'dataloader';
import { queryForRoles, findByIds } from '../server/authorize';

export default class <Type> {
  constructor(context){
	...
	this.loader = new DataLoader((ids, authQuery = {}) => findByIds(this.collection, ids, authQuery));
	...
  }
...
getOneById(id, _user = {}, resolver = 'getOneById') {
  const authQuery = queryForRoles(_user, this.auth, 'readOne', { User: this.context.User }, {_id: id}, resolver);
  return this.loader.load(id, authQuery);
}

all({ lastCreatedAt = 0, limit = 10 }, _user, resolver = 'all') {
  const baseQuery = { createdAt: { $gt: lastCreatedAt } };
  const authQuery = queryForRoles(_user, this.auth, 'readMany', { User: this.context.User }, {_id: 'all'}, resolver);
  const finalQuery = {...baseQuery, ...authQuery};
  return this.collection.find(finalQuery).sort({ createdAt: 1 }).limit(limit).toArray();
}
...
}
```

### ./model/Tweet.js
generated model file for the above input type Tweet.graphql:
this.auth is generated by the @authorize directive. You can see, the directive argument "read" is used to express "readOne" and "readMany" at the same time. Instead you can use "readOne" and "readMany" for fine grained control on read operations, to allow access to just one record or many records.
```javascript
import log from '../server/logger';
import DataLoader from 'dataloader';
import { findByIds, queryForRoles } from '../server/authorize';

export default class Tweet {
  constructor(context) {
    this.context = context;
    this.collection = context.db.collection('tweet');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader((ids, authQuery = {}) => findByIds(this.collection, ids, authQuery));
    this.auth = {
      type: 'Tweet',
      userRoles: {
        create: ['admin'],
        read: ['admin', 'world'],
        readOne: ['admin', 'world'],
        readMany: ['admin', 'world'],
        update: ['admin'],
        delete: ['admin'],
      },
      docRoles: {
        create: ['authorId'],
        read: ['authorId', 'coauthorsIds'],
        readOne: ['authorId', 'coauthorsIds'],
        readMany: ['authorId', 'coauthorsIds'],
        update: ['authorId', 'coauthorsIds'],
        delete: ['authorId'],
      },
    }
  }

  findOneById(id) {
    return this.loader.load(id);
  }

  getOneById(id, _user = {}, resolver = 'getOneById') {
    const authQuery = queryForRoles(_user, this.auth, 'readOne', { User: this.context.User }, {_id: id}, resolver);
    return this.loader.load(id, authQuery);
  }

  all({ lastCreatedAt = 0, limit = 10 }, _user, resolver = 'all') {
    const baseQuery = { createdAt: { $gt: lastCreatedAt } };
    const authQuery = queryForRoles(_user, this.auth, 'readMany', { User: this.context.User }, {_id: 'all'}, resolver);
    const finalQuery = {...baseQuery, ...authQuery};
    return this.collection.find(finalQuery).sort({ createdAt: 1 }).limit(limit).toArray();
  }
  ...
}
```

### ./model/User.js
generated model file for the above input type User.graphql:
this.auth is generated by the @authorize directive. Here also with field authorizations.
```javascript
import log from '../server/logger';
import DataLoader from 'dataloader';
import { findByIds, queryForRoles } from '../server/authorize';

export default class User {
  constructor(context) {
    this.context = context;
    this.collection = context.db.collection('user');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader((ids, authQuery = {}) => findByIds(this.collection, ids, authQuery));
    this.auth = {
      type: 'User',
      userRoles: {
        create: ['admin'],
        read: ['admin'],
        readOne: ['admin'],
        readMany: ['admin'],
        update: ['admin'],
        delete: ['admin'],
      },
      docRoles: {
        create: [],
        read: [],
        readOne: ['_id'], // == 'this'
        readMany: [],
        update: ['_id'],
        delete: ['_id'],
      },
      fields: [
        { 
          name: 'role', 
          userRoles: {
            create: ['admin'],
            read: ['admin'],
            readOne: ['admin'],
            readMany: ['admin'],
            update: ['admin'],
            delete: ['admin'],
          },
          docRoles: {
            create: [],
            read: [],
            readOne: ['_id'], // == 'this'
            readMany: [],
            update: [],
            delete: ['_id'],
          },
        }
      ]
    }
  }

  authRole(user){
    return (user && user.role) ? user.role : '<no-role>';
  }

  findOneById(id) {
    return this.loader.load(id);
  }

  getOneById(id, _user = {}, resolver = 'getOneById') {
    const authQuery = queryForRoles(_user, this.auth, 'readOne', { User: this.context.User }, {_id: id}, resolver);
    return this.loader.load(id, authQuery);
  }

  all({ lastCreatedAt = 0, limit = 10 }, _user, resolver = 'all') {
    const baseQuery = { createdAt: { $gt: lastCreatedAt } };
    const authQuery = queryForRoles(_user, this.auth, 'readMany', { User: this.context.User }, {_id: 'all'}, resolver);
    const finalQuery = {...baseQuery, ...authQuery};
    return this.collection.find(finalQuery).sort({ createdAt: 1 }).limit(limit).toArray();
  }
  ...
}
```


### function findByIds
This is an extended version of [mongo-find-by-ids](https://github.com/tmeasday/mongo-find-by-ids).
The enhancement is only to provide an additional authQuery object, to extend the query to meet additional authorizations.
```javascript
// enhanced version of tmeasday's findByIds plus authQuery handling
export function findByIds(collection, ids = [], authQuery = {}) {
 const baseQuery = { _id: { $in: ids } };
 const finalQuery = {...baseQuery, ...authQuery};
   return collection.find(finalQuery)
   .toArray()
   .then((docs) => {
     const idMap = {};
     docs.forEach((d) => { idMap[d._id] = d; });
     return ids.map(id => idMap[id]);
   });
}
```

### function queryForRoles
Use function queryForRoles to generate an authQuery object.

It expects the following arguments:
```javascript
// creates an authQuery object with additional query arguments, 
// to implement authorization restrictions for mongodb access
export function queryForRoles(user = {}, auth = {}, mode = '', { User }, doc = {}, resolver = '') {

  // Build query for the case: The logged in user's role is authorized
  if (roleAuthorizedForDoc(user, auth, mode, { User }, doc, resolver)) {
    return {};  // empty authQuery means, do operation with no access restrictions
  }

  // Build query for the case: The user is listed in any document field
  const query = { $or: [] };
  if (userAuthorizedForDoc(user, auth, mode, { User }, doc, resolver)){
    const docRoles =  auth.docRoles[mode] || [];
    docRoles.forEach(docRole => query.$or.push( { [docRole]: user._id } ) );
    log.debug('authQuery:', JSON.stringify(query, null, 2));
    return query;
  }

  // Not Authorized
  throw new Error(`Authorization: Not authorized to ${mode} ${auth.type} ${doc._id ? doc._id : ''}.`); 
}
```

It expects the following arguments with the meanings:
* **user:** this is the logged in user object out of the resolver's context
* **auth:** this is the auth object in the model, which was generated by the @authorize directives in the <type>.graphql file
* **mode:** this is the current mode of operation:
	* **create:** insert a record to the database
	* **read:** read a record or many records from the database
		* **readOne:** read only a single record from the database
		* **readMany:** read many records from the the database
	* **update:** update a record in the database
	* **delete:** remove a record from the database
* **doc:** the current document to be checked for authorizations
* **resolver:** this is a string with the resolver's name, optional, only for easier debugging

### function roleAuthorizedForDoc
This helper function is used by queryForRoles, and decides, if a user gains the authorization by its role.
For example: If a user has a field "role" in his user document and it contains the value "admin". So it checks if a user's role is admin, and allows all operations for admins.
```javascript
// returns true, if the user's role is authorized for a document
export function roleAuthorizedForDoc(user = {}, auth = {}, mode = '', { User }, doc = {}, resolver = ''){
  const userRoles = auth.userRoles[mode] || [];
  const role = User.authRole(user);
  const fields = auth.fields || [];

  if ( userRoles.includes('world') || role && role !== '' && role !== '<no-role>' && userRoles.length > 0 && userRoles.includes(role) ) {
    let fieldsAuthorized = true;

    // check all fields with @authorize directives, if any of them is not allowed for the role
    fields.forEach(field => {
      // if this field is in the document, 
      if (doc[field.name]) {
        const fieldUserRoles = field.userRoles[mode] || [];
        //check if the user role doesn't allow this field
        if ( fieldUserRoles.length === 0 || ! ( fieldUserRoles.includes(role) || fieldUserRoles.includes('world') ) ){
          fieldsAuthorized = false;
        }
      } 
    });

    // only if all fields of the document are allowed for the role
    if (fieldsAuthorized){
      log.debug(`${resolver} ${mode} with user ${user.username ? user.username : '<no-user>'} for ${auth.type} and ${doc._id ? doc._id : ''}`);
      return true;
    }
    
  }

  return false;
}
```

### function userAuthorizedForDoc
This helper function is used by queryForRoles, and decides, if a user gains the authorization by its userId in the document role fields. For example if a document of type "Tweet" contains a field named "authorId", it checks if the logged in user's id is included in the field "authorId", if so, he gains control over all operations, which are allowed for the document role "author". It can be also more complicated, if you have an array field "coauthorsIds", which includes all userIds of all coauthors, then it checks, if the user is among the the coauthors, if so, it gains control over all coauthors operations.
```javascript
// returns true, if the user is authorized by a document role
export function userAuthorizedForDoc(user = {}, auth = {}, mode = '', { User }, doc = {}, resolver = ''){
  const docRoles =  auth.docRoles[mode] || [];
  const fields = auth.fields || [];
  let userId;
  let authorized = false;

  // document role checks work only with logged in user
  if (!loggedIn(user)) return false;
  userId = user._id.toString();

  // check if any docRole leads to an authorization
  docRoles.forEach(docRole => {
    const docRoleField = doc[docRole];
    let fieldsAuthorized = true;
    // check if the field for the docRole check is in the document, if not, it cannot be checked
    if (docRoleField){
      // check if user is authorized for doc
      if (fieldContainsUserId(docRoleField, userId)){

        // check if user is authorized for the doc's fields
        fields.forEach(field => {
          const fieldDocRoles = field.docRoles[mode] || [];
          // check if restricted field is in the current document, and if the current docRole is not in the docRole of the field
          if (mode !== 'update' && doc[field.name] && !fieldDocRoles.includes(docRole)){
            fieldsAuthorized = false;
          }
          // check if doc contains a $set object, and this contains any of the fields, 
          // and if the current docRole is not in the docRole of the field
          if (mode === 'update' && doc.$set && doc.$set[field.name] && !fieldDocRoles.includes(docRole)){
            fieldsAuthorized = false;
          }
        });

        // only if the same role is authorized for the document and all fields, it is allowed
        if (fieldsAuthorized){
          log.debug(`${resolver} ${mode} with user ${(user.username) ? user.username : '<no-username>'} for ${auth.type} and docRole ${docRole} for doc with id: ${doc._id ? doc._id : ''}`);
          authorized = true;
          return true;
        }

      }
    }
  });

  return authorized;
}
```

### function fieldContainsUserId
This helper function is used by queryForRoles and checks, if the provided field of types: array, object or string contains the userId.
```javascript
// returns true, if a field of type array/object/string contains the userId
export function fieldContainsUserId(docRoleField, userId) {
  let userIdFound = false;

  // handle an array of userIds
  if (_.isArray(docRoleField)){
    docRoleField.forEach(field => {
      if (field.toString() === userId){
        userIdFound = true;
      }
    });
  }

  // handle a field with one userId, must be an object, if it is an ObjectId('<id>')
  if (_.isObject(docRoleField) && docRoleField.toString() === userId){
    userIdFound = true;
  }

  // handle a field with just an userId String
  if (_.isString(docRoleField) && docRoleField.toString() === userId){
    userIdFound = true;
  }

  return userIdFound;
}
```

### ./resolver/User.js
In the resolver interfaces, there are different objects:
* the root object "tweet", contains the document fields
* the args object "args", contains arguments from the graphql query/mutation
* the context object "Tweet", contains the access to the database model of the Tweet collection
* the context object "_user", contains the current logged in user -if logged in-, which is provided from the server's passport implementation
* the last argument in the resolver function is the resolver's name, which is optional and only to enhance the logging in debugging mode by additional information. If you have to analyze authorization outcomes, this helps a lot to figure out, which resolvers authorization rule fired.
```javascript
const resolvers = {
  Tweet: {
    id(tweet) {
      return tweet._id;
    },

    author(tweet, args, { Tweet, _user }) {
      return Tweet.author(tweet, _user, 'author');
    },

    createdBy(tweet, args, { Tweet, _user }) {
      return Tweet.createdBy(tweet, _user, 'createdBy');
    },

    updatedBy(tweet, args, { Tweet, _user }) {
      return Tweet.updatedBy(tweet, _user, 'updatedBy');
    },

    coauthors(tweet, { lastCreatedAt, limit }, { Tweet, _user }) {
      return Tweet.coauthors(tweet, { lastCreatedAt, limit }, _user, 'coauthors');
    },

    likers(tweet, { lastCreatedAt, limit }, { Tweet, _user }) {
      return Tweet.likers(tweet, { lastCreatedAt, limit }, _user, 'likers');
    },
  },
  Query: {
    tweets(root, { lastCreatedAt, limit }, { Tweet, _user }) {
      return Tweet.all({ lastCreatedAt, limit }, _user, 'tweets');
    },

    tweet(root, { id }, { Tweet, _user }) {
      return Tweet.getOneById(id, _user, 'tweet');  
    },
  },
  Mutation: {
    async createTweet(root, { input }, { Tweet, _user }) {
      const id = await Tweet.insert(input, _user);
      return Tweet.getOneById(id, _user, 'createTweet'); 
    },

    async updateTweet(root, { id, input }, { Tweet, _user }) {
      await Tweet.updateById(id, input, _user);
      return Tweet.getOneById(id, _user, 'updateTweet');
    },

    async removeTweet(root, { id }, { Tweet, _user }) {
      return await Tweet.removeById(id, _user, 'removeTweet');
    },
  },
  Subscription: {
    tweetCreated: tweet => tweet,
    tweetUpdated: tweet => tweet,
    tweetRemoved: id => id,
  },
};

export default resolvers;
```

### Testing
If you run within the project root at least one time, it generates the database and adds the seed tweet and user documents once during each run.
```bash
yarn end-to-end-test
```
It executes many pre-defined tests with different user-roles and document-roles. May be you want to add additional tests to enhance the security of the logic.

If you want to test with the http://localhost:3000/graphiql frontend, best download the following app:
```bash
brew cask install graphiql
```
...and generate a JWT token for your test user by running:
```bash
babel-node ./test/output-app-end-to-end/scripts/generateJWT.js
```
This generates JWT tokens for the different test users from the ./test/seeds/User.json. Copy the wanted JWT token of the different users, and start the GraphiQL app with the following entries:

* GraphQL endpoint: ```http://localhost:3000/graphql```
* Method: ```POST```
* Edit HTTP headers:
  * Header name: ```authorization```
  * Header value: ```JWT the-copied-token``` 

...and write and execute your queries/mutations in the GraphiQL window.

If you use different user's JWT tokens, you can simulate the different user roles such as "admin", "editor" and "user" manually.

