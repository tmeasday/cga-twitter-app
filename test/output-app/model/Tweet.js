import _ from 'lodash';
import log from '../server/logger';
import DataLoader from 'dataloader';
import findByIds from 'mongo-find-by-ids';
import { CREATE, READ, READONE, READMANY, UPDATE, DELETE, DEBUG } from './constants';

export default class Tweet {
  constructor(context) {
    /*  this is generated from ...
        @authorize(
          admin: ["read", "update", "delete"], 
          author: ["create", "read", "update", "delete"], 
          coauthors: ["read", "update"],
          world: ["read"]
        )
    */
    this.authorizations = {
      admin: {
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
      author: {
        create: true,
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
      coauthors: {
        read: true,
        readOne: true,
        readMany: true,
        update: true,
      },
      world: {
        read: true,
        readOne: true,
        readMany: true,
      }
    };
    this.context = context;
    this.collection = context.db.collection('tweet');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader(ids => findByIds(this.collection, ids));
  }

  // returns true, if the user's role is of expected kind
  // this is generated whenever @authorize appears in the type definition
  hasUserRole({role, doc, user, mode, printLog = true, resolver}){
    let hasRole = false;
    switch (role) {
      // returns true, if signed in user has a role "admin"
      // this is generated by...
      // @authorize(admin: ["read", "update", "delete"]) 
      //            -----
      // and if there is no @authRole("admin") user on any of the fields
      // then it assumes a role definition
      // and it checks against the role of the signed in user
      case 'admin':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // the current user has the correct role
          this.context.User.role(user) === 'admin'
        );
        break;
      // returns true, if the signed in user is an author
      // this is generated by...
      // author: User! @unmodifiable @belongsTo @authRole("author")
      //         -----                          -------------------
      case 'author':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // valid document author available
          !!doc && !!doc.authorId && doc.authorId.toString() !== '' &&
          // document author equals signed in user
          doc.authorId.toString() === user._id.toString()
        );
        break;
      // returns true, if the signed in user is one of the coauthors
      // this is generated by...
      // coauthors: [User!] @belongsTo @authRole("coauthors")
      //            -------            ----------------------
      case 'coauthors':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // document has at least one coauthors
          !!doc && !!doc.coauthorsIds && _.isArray(doc.coauthorsIds) && doc.coauthorsIds.length > 0 &&
          // current signed in user is a coauthors
          _.indexOf(doc.coauthorsIds, user._id.toString()) > -1
        );
        break;
      // returns true, if user has a role "world"
      // this is generated by...
      // @authorize(world: ["read"])
      //            -----
      // and if there is no @authRole("world") user on any of the fields
      // then it assumes the special role definition "world"
      // which means for every user, signed in or not signed in
      case 'world':
        hasRole = true;
        break;
    }
    if (printLog){
      log.debug('');
      log.debug(`${resolver} hasRole: "${role}" "${
        user.username ? user.username : ''
      } ${
        user.role ? user.role : ''
      } ${
        user._id ? user._id : ''
      } doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc>'
      }" author: "${
        (doc && doc.authorId) ? doc.authorId : '<no author>'
      }" coauthors: "${
        (doc && doc.coauthorsIds && doc.coauthorsIds.length > 0) ? doc.coauthorsIds.toString() : '<no coauthors>'
      }" ==> "${hasRole}"`);
    }
    return hasRole;
  }

  // returns true, if the user role is authorized for the current mode
  // this is generated whenever @authorize appears in the type definition
  isRoleAuthorizedForMode({role, mode, resolver}){
    log.debug(`${resolver} isRoleAuthorizedForMode: "${role}" "${mode}" ==> "${this.authorizations[role][mode] ? true : false}"`);
    return this.authorizations[role][mode] ? true : false;
  }

  // returns true, if the current user is authorized for the current mode and document
  // this is generated, whenever @authorize appears...
  isAuthorized({doc, mode, user, resolver}){
    // generated by @authorize(admin: ...)
    const adminAuthorized = this.hasUserRole({role: 'admin', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'admin', mode, resolver});

    // logging for debugging...
    if (adminAuthorized){
      log.debug(`${resolver} isAuthorized: role: "${
        (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : '<no role found>'
      }" "${mode}" doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${adminAuthorized}"`);

      return adminAuthorized;
    }

    // generated by @authorize(author: ...)
    const authorAuthorized = this.hasUserRole({role: 'author', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'author', mode, resolver});

    // logging for debugging...
    if (authorAuthorized){
      log.debug(`${resolver} isAuthorized: role: "author" "${mode}" doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" author: "${
        (doc && doc.authorId) ? doc.authorId : '<no author>'
      }" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${authorAuthorized}"`);

      return authorAuthorized;
    }

    // generated by @authorize(coauthors: ...)
    const coauthorsAuthorized = this.hasUserRole({role: 'coauthors', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'coauthors', mode, resolver});

    // logging for debugging...
    if (coauthorsAuthorized){
      log.debug(`${resolver} isAuthorized: role: "coauthors" "${mode}" doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" coauthors: "${
        (doc && doc.coauthorsIds && doc.coauthorsIds.length > 0) ? doc.coauthorsIds.toString() : '<no coauthor>'
      }" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${coauthorsAuthorized}"`);

      return coauthorsAuthorized;
    }

    // generated by @authorize(world: ...)
    const worldAuthorized = this.hasUserRole({role: 'world', doc, user, mode, printLog: true, resolver}) && 
      this.isRoleAuthorizedForMode({role: 'world', mode, resolver});

    // logging for debugging...
    if (worldAuthorized){
      log.debug(`${resolver} isAuthorized: role: "world" "${mode}" doc: "${
        (doc && doc._id) ? doc._id.toString() : '<no doc found>'
      }" user: "${
        (user && user._id) ? user._id.toString() : '<no user found>'
      }" ===> "${worldAuthorized}"`);

      return worldAuthorized;
    }

    // logging for debugging...
    log.debug(`${resolver} isAuthorized: role: "${
      (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : '<no role found>'
    }" "${mode}" doc: "${
      (doc && doc._id) ? doc._id.toString() : '<no doc found>'
    }" author: "${
        (doc && doc.authorId) ? doc.authorId : '<no author>'
    }" coauthors: "${
        (doc && doc.coauthorsIds && doc.coauthorsIds.length > 0) ? doc.coauthorsIds.toString() : '<no coauthor>'
    }" user: "${
      (user && user._id) ? user._id.toString() : '<no user found>'
    }" ===> "false"`);

    return false;
  }

  // returns document without role field
  // generated by...
  // role: String! @authRole("admin") @authorize(this: ["read"], admin: ["read", "update"])
  //       ------- ------------------ 
  authorizedFields({doc, mode, user, resolver}){
    // array contains all fields, whose authorization is to be checked
    // role: String! @authorize()
    // ----          ------------
    const fields = [];

    // check authorization on field level now
    fields.forEach(field => {
      // default is: field is not authorized
      let authorizedField = false;

      // ... Checking fields here...

      // otherwise remove field from doc, 
      // because the user and mode is not authorize to access this field
      if ( !authorizedField && doc[field] ){
        log.debug(`${resolver} authorizedFields: "${field}" not authorized for user/role and mode: "${mode}", removed from document`);
        delete doc[field];
      }
    });

    return doc;
  }

  // returns only authorized documents and fields
  // generated by ...
  // @authorize()
  authorized({doc, mode, user, resolver}){
    // if it is an array of documents, ....
    if (_.isArray(doc)){
      // then filter for the authorized documents
      let authorizedDocs = _.filter(doc, d => this.isAuthorized({doc: d, mode, user, resolver}) );
      // provide only authorized fields
      authorizedDocs.forEach(d => {
        d = this.authorizedFields({doc: d, mode, user, resolver});
      });
      return authorizedDocs;

    // if it is a single document, check the authorization for it
    } else if ( _.isObject(doc) && this.isAuthorized({doc, mode, user, resolver}) ) {
      // return only authorized fields
      const authorizedDoc = this.authorizedFields({doc, mode, user, resolver});
      return authorizedDoc;
    }

    // or return null, if no authorized document was found
    log.debug(`${resolver} authorized: no authorized doc found`);
    return null;
  }

  async getById(id, _user, resolver){
    const doc = await this.findOneById(id);
    return this.authorized({doc, mode: READONE, user: _user, resolver});
  }

  findOneById(id) {
    return this.loader.load(id);
  }

  async getAll({ lastCreatedAt, limit }, _user, resolver){
    const doc = await this.all({ lastCreatedAt, limit }, _user);
    return this.authorized({doc, mode: READMANY, user: _user, resolver});
  }

  all({ lastCreatedAt = 0, limit = 10 }, _user) {
    return this.collection.find({
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  author(tweet, _user) {
    return this.context.User.getById(tweet.authorId, _user, 'author');
  }

  createdBy(tweet, _user) {
    return this.context.User.getById(tweet.createdById, _user, 'createdBy');
  }

  updatedBy(tweet, _user) {
    return this.context.User.getById(tweet.updatedById, _user, 'udpatedBy');
  }

  async coauthors(tweet, { lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.User.collection.find({
      _id: { $in: tweet.coauthorsIds },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    return this.context.User.authorized({doc, mode: READMANY, user: _user, resolver: 'coauthors'});
  }

  async likers(tweet, { lastCreatedAt = 0, limit = 10 }, _user) {
    const doc = await this.context.User.collection.find({
      likedIds: tweet._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    return this.context.User.authorized({doc, mode: READMANY, user: _user, resolver: 'likers'});
  }

  async insert(doc, _user) {
    // let coauthorsIds = doc.coauthorsIds || [];
    // const enhancedDoc = Object.assign({
    //   authorId: user._id,
    //   coauthorsIds: coauthorsIds,
    // });
    let docToInsert = Object.assign({}, doc, {
      createdAt: Date.now(),
      updatedAt: Date.now(),
      createdById: (_user && _user._id) ? _user._id : 'unknown',
      updatedById: (_user && _user._id) ? _user._id : 'unknown',
    });
    docToInsert = this.authorizedFields({doc: docToInsert, mode: CREATE, user: _user, resolver: 'insert'});
    const authorized = this.isAuthorized({doc: docToInsert, mode: CREATE, user: _user, resolver: 'insert'});
    if (!authorized) throw new Error('Tweet: mode: create not authorized');

    const id = (await this.collection.insertOne(docToInsert)).insertedId;
    this.pubsub.publish('tweetInserted', await this.findOneById(id));
    return id;
  }

  async updateById(id, doc, _user) {
    const foundDoc = await this.findOneById(id);
    const authorized = this.isAuthorized({doc: foundDoc, mode: UPDATE, user: _user, resolver: 'updateById'});
    if (!authorized) throw new Error('Tweet: mode: update not authorized');

    const updatedDoc = this.authorizedFields({doc, mode: UPDATE, user: _user, resolver: 'updateById'});
    const ret = await this.collection.update({ _id: id }, {
      $set: Object.assign({}, updatedDoc, {
        updatedAt: Date.now(),
        updatedById: (_user && _user._id) ? _user._id : 'unknown',
      }),
    });
    this.loader.clear(id);
    this.pubsub.publish('tweetUpdated', await this.findOneById(id));
    return ret;
  }

  async removeById(id, _user) {
    const doc = await this.findOneById(id);
    const authorized = this.isAuthorized({doc, mode: DELETE, user: _user, resolver: 'removeById'});
    if (!authorized) throw new Error('Tweet: mode: delete not authorized');

    const ret = this.collection.remove({ _id: id });
    this.loader.clear(id);
    this.pubsub.publish('tweetRemoved', id);
    return ret;
  }
}
