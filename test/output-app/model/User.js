import _ from 'lodash';
import DataLoader from 'dataloader';
import findByIds from 'mongo-find-by-ids';
import { CREATE, READ, READONE, READMANY, UPDATE, DELETE, DEBUG } from './constants';

export default class User {
  constructor(context) {
    /*  this is generated from ...
        @authorize(
          this: ["readOne", "update", "delete"]
          admin: ["create", "read", "update", "delete"]
        )
    */
    this.authorizations = {
      this: {
        readOne: true,
        update: true,
        delete: true,
      },
      admin: {
        create: true,
        read: true,
        readOne: true,
        readMany: true,
        update: true,
        delete: true,
      },
    };
    this.context = context;
    this.collection = context.db.collection('user');
    this.pubsub = context.pubsub;
    this.loader = new DataLoader(ids => findByIds(this.collection, ids));
  }

  // returns true, if the user's role is of expected kind
  // this is generated whenever @authorize appears in the type definition
  hasUserRole({role, doc, user, mode}){
    let hasRole = false;
    switch (role) {

      // returns true, if the signed in user is equal to the document id 
      // this is generated by...
      // @authorize(this:)
      //            -----
      case 'this':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // valid document user id available
          !!doc && !!doc._id && doc._id.toString() !== '' &&
          // document user id equals signed in user
          doc._id.toString() === user._id.toString()
        );
        break;

      // returns true, if signed in user has a role "admin"
      // this is generated by...
      // @authorize(admin: ["create", "read", "update", "delete"]) 
      //            -----
      // and if there is no @authRole("admin") user on any of the fields
      // then it assumes a role definition
      // and it checks against the role of the signed in user
      case 'admin':
        hasRole = (
          // valid signed in user id available
          !!user && !!user._id && user._id.toString() !== '' &&
          // the current user has the correct role
          this.context.User.role(user) === 'admin'
        );
        break;

    }

    (DEBUG) ? console.log(
      '\n---------------------------------------------------------------------------------\n',
      'hasRole?','\n',
      'check if role =', role,'\n',
      'for user:', (user) ? (user.username, user.role, user._id) : (''), '\n',
      'doc:', JSON.stringify(doc, null, 2),'\n',
      '==>', hasRole
      )
    : null;

    return hasRole;
  }

  // returns true, if the user role is authorized for the current mode
  // this is generated whenever @authorize appears in the type definition
  isRoleAuthorizedForMode({role, mode}){
    (DEBUG) ? 
      console.log(
        'isRoleAuthorizedForMode?', '\n',
        'role:', role, 
        'mode:', mode, 
        '==>', this.authorizations[role][mode] ? true : false,
        '\n---------------------------------------------------------------------------------\n',
      ) 
      : null;
    return this.authorizations[role][mode] ? true : false;
  }

  // returns true, if the current user is authorized for the current mode and document
  // this is generated, whenever @authorize appears...
  isAuthorized({doc, mode, user}){
    // for authorization debugging and logging reasons, do individual checks...
    if (mode === CREATE){
      console.log('\n\nisAuthorized:\n', JSON.stringify(doc, null, 2), '\n\n\n');
    }

    // generated by @authorize(this: ...)
    const thisAuthorized = this.hasUserRole({role: 'this', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'this', mode});
    if (thisAuthorized && DEBUG) {
      console.log(
        'Mode:', mode, 
        'User Doc:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        "===>", 'Authorized:', thisAuthorized
      );
    }

    // generated by @authorize(admin: ...)
    const adminAuthorized = this.hasUserRole({role: 'admin', doc, user, mode}) && 
      this.isRoleAuthorizedForMode({role: 'admin', mode});
    if (adminAuthorized && DEBUG){
      console.log(
        'Mode:', mode, 
        'User doc:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        'Role:', (user && user._id && this.context.User.role(user)) ? this.context.User.role(user) : 'Error', 
        "===>", 'Authorized:', adminAuthorized
      );
    }

    // generated by @authorize(this: ..., admin: ...)
    const authResult = thisAuthorized || adminAuthorized;
    if (!authResult && DEBUG) {
      console.log(
        'Mode:', mode, 
        'Tweet:', (doc && doc._id) ? doc._id.toString() : '', 
        'User:', (user && user._id) ? user._id.toString() : '', 
        "===>", 'Authorized:', authResult
      );
    }

    return authResult;
  }

  // returns the role of the current user 
  // generated by...
  // role: String! @authRole("admin") @authorize(this: ["read"], admin: ["read", "update"])
  //       ------- ------------------
  // whereas the field is not of type User, it is of type String
  role(user){
    return (user && user.role) ? user.role : null;
  }

  // returns document without role field
  // generated by...
  // role: String! @authRole("admin") @authorize(this: ["read"], admin: ["read", "update"])
  //       ------- ------------------ 
  authorizedFields({doc, mode, user}){
    // array contains all fields, whose authorization is to be checked
    const fields = ['role'];

    // check authorization on field level now
    fields.forEach(field => {
      // default is: field is not authorized
      let authorizedField = false;

      if (field === 'role'){
        // role: @authorize(this: ["read"])
        if ( this.hasUserRole({role: 'this', doc, user, mode}) &&
          (mode === READ || mode === READONE || mode === READMANY) ){
           authorizedField = true;
        }

        // role: @authorize(admin: ["create", "read", "update"])
        if ( this.hasUserRole({role: 'admin', doc, user, mode})  &&
          (mode === CREATE || mode === READ || mode === READONE || mode === READMANY || mode === UPDATE) ){
           authorizedField = true;
        }
      }

      // role: otherwise remove field from doc, 
      // because the user and mode is not authorize to access this field
      if ( !authorizedField && doc[field] ){
        delete doc[field];
      }
    });

    return doc;
  }

  // returns only authorized documents and fields
  // generated by ...
  // @authorize()
  authorized({doc, mode, user}){
    if (!user) throw new Error('authorized: user is empty');
    // if it is an array of documents, ....
    if (_.isArray(doc)){
      // then filter for the authorized documents
      let authorizedDocs = _.filter(doc, d => this.isAuthorized({doc: d, mode, user}) );
      // provide only authorized fields
      authorizedDocs.forEach(d => {
        d = this.authorizedFields({doc: d, mode, user});
      });
      return authorizedDocs;

    // if it is a single document, check the authorization for it
    } else if ( _.isObject(doc) && this.isAuthorized({doc, mode, user}) ) {
      // return only authorized fields
      const authorizedDoc = this.authorizedFields({doc, mode, user});
      return authorizedDoc;

    // or return null, if no authorized document was found
    } else {
      console.log('authorized: no authorized doc found');
      return null;
    }
  }

  async findOneById(id, user) {
    const doc = await this.loader.load(id);
    // const authorizedDoc = this.authorized({doc, mode: READONE, user});
    // return authorizedDoc;
    return doc;
  }

  async all({ lastCreatedAt = 0, limit = 10, user }) {
    const doc = await this.collection.find({
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
    // const authorizedDocs = this.authorized({doc, mode: READMANY, user});
    // return authorizedDocs;
    return doc;
  }

  tweets(user, { minLikes, lastCreatedAt = 0, limit = 10 }) {
    return this.context.Tweet.collection.find({
      authorId: user._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  liked(user, { lastCreatedAt = 0, limit = 10 }) {
    return this.context.Tweet.collection.find({
      _id: { $in: user.likedIds || [] },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  following(user, { lastCreatedAt = 0, limit = 10 }) {
    return this.context.User.collection.find({
      _id: { $in: user.followingIds || [] },
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  followers(user, { lastCreatedAt = 0, limit = 10 }) {
    return this.context.User.collection.find({
      followingIds: user._id,
      createdAt: { $gt: lastCreatedAt },
    }).sort({ createdAt: 1 }).limit(limit).toArray();
  }

  createdBy(user) {
    return this.context.User.findOneById(user.createdById);
  }

  updatedBy(user) {
    return this.context.User.findOneById(user.updatedById);
  }

  async insert(doc, user) {
    let docToInsert = Object.assign({}, doc, {
      createdAt: Date.now(),
      updatedAt: Date.now(),
      createdById: (user && user._id) ? user._id : 'unknown',
      updatedById: (user && user._id) ? user._id : 'unknown',
    });
    docToInsert = this.authorizedFields({doc: docToInsert, mode: CREATE, user});
    const authorized = this.isAuthorized({doc: docToInsert, mode: CREATE, user});
    if (!authorized) throw new Error('User: mode: create not authorized');

    const id = (await this.collection.insertOne(docToInsert)).insertedId;
    this.pubsub.publish('userInserted', await this.findOneById(id));
    return id;
  }

  async updateById(id, doc, user) {
    const foundDoc = await this.findOneById(id);
    console.log('foundDoc', JSON.stringify(foundDoc, null, 2));

    const authorized = this.isAuthorized({doc: foundDoc, mode: UPDATE, user});
    if (!authorized) throw new Error('User: mode: update not authorized');

    const updatedDoc = this.authorizedFields({doc, mode: UPDATE, user});
    console.log('updatedDoc', JSON.stringify(updatedDoc, null, 2));

    const ret = await this.collection.update({ _id: id }, {
      $set: Object.assign({}, updatedDoc, {
        updatedAt: Date.now(),
        updatedById: (user && user._id) ? user._id : 'unknown',
      }),
    });
    this.loader.clear(id);
    this.pubsub.publish('userUpdated', await this.findOneById(id));
    return ret;
  }

  async removeById(id, user) {
    const doc = await this.findOneById(id);
    const authorized = this.isAuthorized({doc, mode: DELETE, user});
    if (!authorized) throw new Error('User: mode: delete not authorized');

    const ret = this.collection.remove({ _id: id });
    this.loader.clear(id);
    this.pubsub.publish('userRemoved', id);
    return ret;
  }
}
